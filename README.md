# re2go Slow Issue

This repository contains code sample for cases where code generated by re2go is magnitude slower than Go's standard `regexp` library.

To run this repository, you can use `make` command or `go run *.go`. Here is the result when run in my PC running Linux with Intel i7-8550U and RAM 16 GB:

```
File "sample/01.html"
  re2go: found 0 matches in 9249 ms
  std  : found 0 matches in 15 ms
  re2go is 616x slower than std

File "sample/02.html"
  re2go: found 0 matches in 7570 ms
  std  : found 0 matches in 14 ms
  re2go is 540x slower than std

File "sample/03.html"
  re2go: found 0 matches in 2030 ms
  std  : found 0 matches in 13 ms
  re2go is 156x slower than std

File "sample/04.html"
  re2go: found 0 matches in 1051 ms
  std  : found 0 matches in 16 ms
  re2go is 65x slower than std
```

### Code Summary

The main code is available in `main.go`. Thanks to Go nature, I believe the code is readable and easy enough to understand. However, for clarity here I write a short summary about this code.

In short, I'm using the following regex pattern to find emails in web pages:

```
[\+\-\.0-9A-Z_a-z]+@[\-\.0-9A-Z_a-z]+[\.][\-\.0-9A-Z_a-z]+
```

For Go's standard library, the regex is generated simply by running `regexp.MustCompile`:

```go
var rxEmail = regexp.MustCompile(`[\+\-\.0-9A-Z_a-z]+@[\-\.0-9A-Z_a-z]+[\.][\-\.0-9A-Z_a-z]+`)
```

For re2go, the code is generated by following `.re` template:

```go
package main

func re2Email(bytes []byte) int {
	var count int
	var cur, mar int
	lim := len(bytes)

	// Peek function
	peek := func(bytes []byte, cur int, lim int) byte {
		if cur < lim {
			return bytes[cur]
		}
		return 0
	}

	for { /*!re2c
		re2c:eof = 0;
		re2c:yyfill:enable = 0;
		re2c:posix-captures = 0;
		re2c:case-insensitive = 0;
		re2c:define:YYCTYPE     = byte;
		re2c:define:YYPEEK      = "peek(bytes, cur, lim)";
		re2c:define:YYSKIP      = "cur += 1";
		re2c:define:YYBACKUP    = "mar = cur";
		re2c:define:YYRESTORE   = "cur = mar";
		re2c:define:YYLESSTHAN  = "lim <= cur";
		re2c:define:YYSTAGP     = "@@{tag} = cur";
		re2c:define:YYSTAGN     = "@@{tag} = -1";
		re2c:define:YYSHIFTSTAG = "@@{tag} += @@{shift}";

		email = [\+\-\.0-9A-Z_a-z]+@[\-\.0-9A-Z_a-z]+[\.][\-\.0-9A-Z_a-z]+;

		{email} { count += 1; continue }
		*       { continue }
		$       { return count }
		*/
	}
}
```

Which then compiled by re2go using following command (see `Makefile` for more detail):

```
re2go -F --input-encoding utf8 --utf8 --no-generation-date -i $INPUT -o $OUTPUT
```

The generated code then compared with Go's standard regexp library using several web pages in [sample](./sample/) directory.
